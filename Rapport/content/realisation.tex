Comme ça a été mentionné dans l’état de l’art la visualisation des grands jeux de donnée souffre de cette malédiction de la dimensionalité. 
Le problème des projections dans ce cas précis n’est pas celui de projeter les données, mais celui de les projeter fidèlement. 
C’est-à-dire, la difficulté pour la méthode à respecter le rapport des distances des points entre le jeu de donné original (à n-dimensions) et la projection finale (qui réduit ce dernier à deux ou 3 dimensions). 
Plus le nombre de dimensions augmente, plus il devient compliqué de respecter les distances après réduction. // Puis suite du paragraphe.

\medskip

Méthodologie : 
Nous avons donc mis en place un programme avec un système de score qui classe l’efficacité des différentes méthodes de réduction/projection pour un même jeu de donné. 
C’est-à-dire que le jeu de donnée va passer une fois dans chaque algorithme, puis le résultat sera mesuré.
Pour mesurer ces résultats nous avons utilisé différents critères issus de la librairie R « clusterCrit » et scikit-learn.
ClusterCrit est une librairie R qui fournit une liste de critéres permettant d'attester de la qualité interne des clusters et une liste de critères qui permet 
de mesurer la similarité entre deux partitions. Ces critères prennent seulement en compte la répartition des points dans les différents cluster et ne permettent pas de 
mesurer la qualité de la distribution.



\section{Implémentation}

\subsection{Jeux de données}
Pour comparer les différentes méthodes nous avons créer plusieurs jeux de donnés qui présentent les caractéristiques suivantes :
\begin{itemize}
    \item deux clusters superposés avec un seul
    \item  trois clusters bien distincts
    \item trois clusters superposés
    \item un cluster entouré de quelques outliers
    \item trois cluster entourés d’outliers
\end{itemize}
Pour les créer nous avons utilisé la méthode \textit{make_blobs} de la librairie \textit{sklearn}. Les paramètres fixes sont :
\begin{itemize}
    \item \textit{n_samples} qui représente le nombre de points total qui sera également réparti entre les différents clusters. Nous l'avons fixé à vingt-mille.
    \item \textit{n_features} qui représente le nombre de variables pour chaque échantillon. Nous l'avons fixé à vingt-et-un.
\end{itemize}
Nous avons fait varier les paramètres suivants pour obtenir la répartition souhaitée : 
\begin{itemize}
    \item \textit{centers} qui détermine le nombre de centres à génerer
    \item \textit{cluster_std} qui détermine l'écart type des clusters
    \item \textit{random_state} qui détermine un nombre aléatoire pour la crétion du jeu de données.
\end{itemize}
\subsection{Méthodes}
\subsection{Résultats}

\section{Experimentation}
